[
  {
    "objectID": "Prefinal.html",
    "href": "Prefinal.html",
    "title": "Anthologie grecque. Visualisations",
    "section": "",
    "text": "Indiquer le nombre de modifications\ncheck bokeh\ncheck seaborn"
  },
  {
    "objectID": "Prefinal.html#le-projet-anthologie-grecque",
    "href": "Prefinal.html#le-projet-anthologie-grecque",
    "title": "Anthologie grecque. Visualisations",
    "section": "Le projet Anthologie grecque",
    "text": "Le projet Anthologie grecque\nDepuis 2014, la Chaire de Recherche du Canada sur les Écritures Numériques porte le projet d’édition numérique collaborative de l’Anthologie grecque. Ce vaste corpus de la littérature grecque a traversé le temps et s’est inscrite sur nombreux de support et media. Au sein de la CRCEN seulement, plusieurs plateforme ont hébergé son contenu.\nLe projet se trouve désormais sur la plateforme Anthologiagraeca. Celui-ci a bénéficié de l’aide d’environ 150 éditeur·ice·s qui opérèrent 12300 actions sur la plateforme (au 20 avril 2023).\nCes contributions sont en réalité des data, que nous pouvons désormais manipuler et qui nous permettent d’appréhender l’Anthologie d’un autre œil, par le biais de visualisations notamment. Celles-ci ont un double avantage :\n\na. État d’avancement de la plateforme\nPlus la plateforme se remplit, plus il devient complexe d’avoir une vision d’ensemble sur l’état d’édition de la plateforme. L’encodage des données selon les standards de l’édition numérique et l’implémentation de l’API nous permettent de visualiser facilement ce qu’il reste à faire pour chacun des livres de l’Anthologie grecque, ou du moins de discerner des priorités.\nLa question du statut ou du degré d’édition des épgirammes de la plateforme est décrit ici.\n\n\nb. Saisir la réalité de l’AG dans son ensemble\nL’Anthologie ne peut se concevoir que comme une œuvre linéaire. En effet, celle-ci est un regroupement d’hétérogènes, dialoguant entre eux par des liens, qu’ils soient tacites ou clairement marqués.\nUne édition numérique comme celle menée à la CRCEN permet une lecture plus cyclique du corpus, et les visualisations proposées ci-dessous offrent des synthèses variées des différentes facette du l’œuvre."
  },
  {
    "objectID": "Prefinal.html#ce-site",
    "href": "Prefinal.html#ce-site",
    "title": "Anthologie grecque. Visualisations",
    "section": "Ce site",
    "text": "Ce site\nCe site est écrit dans JupyterLab, généré en HTML avec Quarto, déployé sur GitHub Pages et mis à jour quotidiennement grâce à GitHub Actions. Le code est public.\nDans la même optique, chaque figure ci-dessous est accompagnée de son code."
  },
  {
    "objectID": "Prefinal.html#prérequis",
    "href": "Prefinal.html#prérequis",
    "title": "Anthologie grecque. Visualisations",
    "section": "Prérequis",
    "text": "Prérequis\nIl convient tout d’abord d’importer les bibliothèques qui nous seront utiles tout le long de notre démonstration :\n\n\nCode\nimport json\nimport requests\nimport csv\nimport pandas as pd\nfrom datetime import datetime\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nprint(\"Import des librairies nécessaires\")\n\n\nImport des librairies nécessaires"
  },
  {
    "objectID": "Prefinal.html#récupérer-les-données-de-lapi",
    "href": "Prefinal.html#récupérer-les-données-de-lapi",
    "title": "Anthologie grecque. Visualisations",
    "section": "Récupérer les données de l’API",
    "text": "Récupérer les données de l’API\nAvant toute chose, récupérons les données de l’API, en tenant compte qu’elle est paginée.\nGrâce à GitHub action, nous faisons tourner ce Jupyter Notebook une fois par jour afin de mettre à jour les visualisations avec les nouvelles données encodées.\nLe code ci-dessous nous permet de récupérer les données de l’API, plus précisément l’endpoint passages qui nous intéresse.\nNos données sont désormais stockées dans la liste api_data.\n\n\nCode\napi_data = []\n\npagination = True\n\nc = 0 \n\nwhile pagination == True: \n    c = c+1\n    param = {'page': c,}\n    basic_url = 'https://anthologiagraeca.org/api/'\n    endpoint = \"passages\"\n    r = requests.get(basic_url + endpoint,param).json()\n    if r['next'] is None:\n        pagination = False\n    for item in r['results']:\n        api_data.append(item)\n\n\nCette commande nous a permis de stocker toutes les données de l’API dans la liste api_data.\nNous pouvons facilement vérifier cela en vérifiant la longueur de la liste : nous devrions obtenir 4134 résultats : le nombre d’épigrammes sur la plateforme.\n\n\nCode\nprint(\"La liste api_data contient\",len(api_data), \"entrées\")\n\n\nLa liste api_data contient 4134 entrées\n\n\nVoyons également à quoi ressemble la structure des données :\n\n\nCode\napi_data[1]\n\n\n{'id': 438,\n 'book': {'url': 'https://anthologiagraeca.org/api/books/9/', 'number': 1},\n 'fragment': 2,\n 'sub_fragment': '',\n 'url': 'https://anthologiagraeca.org/api/passages/urn:cts:greekLit:tlg7000.tlg001.ag:1.2/',\n 'manuscripts': ['http://digi.ub.uni-heidelberg.de/iiif/2/cpgraec23%3A049.jpg/pct:12.466722876141418,19.26407429979108,58.60226718012693,8.23287268450456/full/0/default.jpg'],\n 'texts': [{'url': 'https://anthologiagraeca.org/api/texts/1627/',\n   'language': 'grc',\n   'text': '\\n                      θεῖος Ἰουστῖνος, Σοφίης πόσις, ᾧ πόρε Χριστὸς\\n πάντα διορθοῦσθαι, καὶ κλέος ἐν πολέμοις,\\nμητρὸς ἀπειρογάμοιο δόμον σκάζοντα νοήσας,\\n σαθρὸν ἀποσκεδάσας τεῦξέ μιν ἀσφαλέως.\\n'},\n  {'url': 'https://anthologiagraeca.org/api/texts/1628/',\n   'language': 'eng',\n   'text': 'Inscribed on the Apse of Blachernae\\n\\nThe divine Justin, the husband of Sophia, to whom Christ granted the gift of restoring everything, and glory in war, finding that the temple of the Virgin Mother was tottering, took the decayed part to pieces and built it up again securely. '},\n  {'url': 'https://anthologiagraeca.org/api/texts/1629/',\n   'language': 'fra',\n   'text': \"Gravé sur les absides des Blachernes. \\n\\nLe divin Justin, l'époux de Sophie, à qui le Christ a accordé le rétablissement universel de l'ordre et la gloire dans les combats, voyant chanceler la demeure de la Mère immaculée, en a fait abattre les bâtiments qui tombaient en ruines et les a fait reconstruire solidement. \"},\n  {'url': 'https://anthologiagraeca.org/api/texts/1630/',\n   'language': 'por',\n   'text': 'Na abóboda de Blaquerna\\n\\nO divino Justino, esposo de Sofia, a quem Cristo concedeu o dom de tudo restaurar e a glória em combates, percebendo estar combalida a casa da Mãe Imaculada, demoliu o danificado e reconstruiu solidamente. '}],\n 'authors': [{'url': 'https://anthologiagraeca.org/api/authors/6/',\n   'tlg_id': '',\n   'names': [{'name': 'anónimo', 'language': 'spa'},\n    {'name': 'anonimo', 'language': 'ita'},\n    {'name': 'anonyme', 'language': 'fra'},\n    {'name': 'anónimo', 'language': 'por'},\n    {'name': 'anonymus', 'language': 'lat'},\n    {'name': 'anonymous', 'language': 'eng'}]}],\n 'cities': [],\n 'keywords': ['https://anthologiagraeca.org/api/keywords/116/',\n  'https://anthologiagraeca.org/api/keywords/200/'],\n 'scholia': [{'book': 1,\n   'fragment': 2,\n   'sub_fragment': '',\n   'number': 1,\n   'url': 'https://anthologiagraeca.org/api/scholia/urn:cts:greekLit:tlg5011.tlg001.sag:1.2.1/'},\n  {'book': 1,\n   'fragment': 2,\n   'sub_fragment': '',\n   'number': 2,\n   'url': 'https://anthologiagraeca.org/api/scholia/urn:cts:greekLit:tlg5011.tlg001.sag:1.2.2/'}],\n 'comments': [],\n 'external_references': [{'title': 'Église Sainte-Marie des Blachernes',\n   'url': 'https://fr.wikipedia.org/wiki/%C3%89glise_Sainte-Marie-des-Blachernes'}],\n 'internal_references': [],\n 'media': []}\n\n\nNous pouvons en outre stocker ces données dans un fichier .json. Vu que ces données sont retéléchargées chaque jour, nous ajoutons un paramètre pour renommer notre fichier en fonction du jour de téléchargement.\n\n\nCode\nwith open(f'api_json_{datetime.now().date()}.json', 'w') as js:\n    json.dump(api_data, js)"
  },
  {
    "objectID": "Prefinal.html#stocker-les-données-dans-un-csv-pour-les-manipuler-avec-panda",
    "href": "Prefinal.html#stocker-les-données-dans-un-csv-pour-les-manipuler-avec-panda",
    "title": "Anthologie grecque. Visualisations",
    "section": "Stocker les données dans un csv pour les manipuler avec panda 🐼",
    "text": "Stocker les données dans un csv pour les manipuler avec panda 🐼\nPandas est une bibliothèque Python permettant de manipuler et d’analyser des données, tout en proposant de simples visualisations.\nSi le panda 🐼 se nourrit de bambou 🌿, notre Panda 🐍 se nourrit plutôt de tableaux .csv 🖥\nNous commencerons par créer un premier fichier .csv, intitulé main_info.csv dont les colonnes reprendront les informations suivantes :\n\nl’URL de l’épigramme ;\nle numéro de l’épigramme ;\nle livre de l’épigramme ;\nla présence ou non d’un manuscrit ;\nle nombre de textes associés à l’épigramme ;\nle nombre de mots-clés associés à l’épigramme ;\nle nombre de scholies associés à l’épigramme ;\nle nombre de commentaires associés à l’épigramme ;\n\n\n\nCode\nheader = ['URL', 'epigram', 'book', 'manuscripts', 'texts', 'keywords', 'scholia', 'comments']\n\nwith open('main_info.csv', mode='w', newline='', encoding='utf-8') as file:\n        writer = csv.DictWriter(file, fieldnames=header)\n        writer.writeheader()\n        for row in api_data:\n            url = row.get('url', '')\n            epigram = url.split('ag:')[1].split('/')[0] if 'ag:' in url else ''\n            book = row.get('book', {}).get('number')\n            manuscripts = True if row.get('manuscripts') else False\n            texts = len(row.get('texts', []))\n            keywords = len(row.get('keywords', []))\n            scholia = len(row.get('scholia', []))\n            comments = len(row.get('comments', []))\n            writer.writerow({\n            'URL': url,\n            'epigram': epigram,\n            'book': book,\n            'manuscripts': manuscripts,\n            'texts': texts,\n            'keywords': keywords,\n            'scholia': scholia,\n            'comments': comments\n        })\n\n\nLe fichier main_info.csv a été créé ; nous pouvons désormais le lire et le manipuler. Commençons par en afficher un échantillon aléatoire de 5 lignes :\n\n\nCode\napi_data_df = pd.read_csv('main_info.csv', delimiter=\",\")\n\napi_data_df.sample(5)\n\n\n\n\n\n\n  \n    \n      \n      URL\n      epigram\n      book\n      manuscripts\n      texts\n      keywords\n      scholia\n      comments\n    \n  \n  \n    \n      393\n      https://anthologiagraeca.org/api/passages/urn:...\n      5.236\n      5\n      True\n      3\n      4\n      2\n      0\n    \n    \n      3608\n      https://anthologiagraeca.org/api/passages/urn:...\n      14.74\n      14\n      False\n      3\n      0\n      0\n      0\n    \n    \n      2816\n      https://anthologiagraeca.org/api/passages/urn:...\n      11.16\n      11\n      True\n      3\n      9\n      0\n      0\n    \n    \n      968\n      https://anthologiagraeca.org/api/passages/urn:...\n      7.140\n      7\n      True\n      4\n      10\n      3\n      1\n    \n    \n      1360\n      https://anthologiagraeca.org/api/passages/urn:...\n      7.527\n      7\n      True\n      4\n      6\n      2\n      0"
  },
  {
    "objectID": "Prefinal.html#focus-sur-les-textes",
    "href": "Prefinal.html#focus-sur-les-textes",
    "title": "Anthologie grecque. Visualisations",
    "section": "Focus sur les textes",
    "text": "Focus sur les textes\nDans cette section, nous nous intéresserons principalement aux nombre de textes qu’ont les épigrammes sur notre plateforme.\nCommençons dès lors par afficher dans notre table les données qui nous intéressent.\n\n\nCode\napi_data_df[['book','epigram','texts']]\n\n\n\n\n\n\n  \n    \n      \n      book\n      epigram\n      texts\n    \n  \n  \n    \n      0\n      1\n      1.1\n      4\n    \n    \n      1\n      1\n      1.2\n      4\n    \n    \n      2\n      1\n      1.3\n      4\n    \n    \n      3\n      1\n      1.4\n      4\n    \n    \n      4\n      1\n      1.5\n      4\n    \n    \n      ...\n      ...\n      ...\n      ...\n    \n    \n      4129\n      16\n      16.384\n      2\n    \n    \n      4130\n      16\n      16.385\n      2\n    \n    \n      4131\n      16\n      16.386\n      2\n    \n    \n      4132\n      16\n      16.387\n      2\n    \n    \n      4133\n      16\n      16.388\n      2\n    \n  \n\n4134 rows × 3 columns\n\n\n\nAvant d’aller plus loin, nous pouvons déjà nous rendre compte et visualiser (sous plusieurs formes différentes) combien de textes ont les épigrammes:\n\n\nCode\napi_data_df['texts'].value_counts()\n\n\n3     1563\n1      888\n4      877\n2      553\n5      176\n6       55\n7        9\n8        6\n9        4\n0        2\n11       1\nName: texts, dtype: int64\n\n\nLa plupart des épigrammes, 1598, ont trois textes ; une épigramme possède même 11 textes ! Par contre, 888 épigrammes n’ont encore qu’un seul texte. Pour connaitre les épigrammes dont il est question, nous pouvons appliquer un filtre, comme ceci :\n\n\nCode\neleven_texts_filter = api_data_df['texts'] == 11\none_text_filter = api_data_df['texts'] == 1\n\n\n\n\nCode\napi_data_df[eleven_texts_filter]\n\n\n\n\n\n\n  \n    \n      \n      URL\n      epigram\n      book\n      manuscripts\n      texts\n      keywords\n      scholia\n      comments\n    \n  \n  \n    \n      1912\n      https://anthologiagraeca.org/api/passages/urn:...\n      9.70\n      9\n      True\n      11\n      0\n      1\n      0\n    \n  \n\n\n\n\n\n\nCode\napi_data_df[one_text_filter]\n\n\n\n\n\n\n  \n    \n      \n      URL\n      epigram\n      book\n      manuscripts\n      texts\n      keywords\n      scholia\n      comments\n    \n  \n  \n    \n      133\n      https://anthologiagraeca.org/api/passages/urn:...\n      3.1\n      3\n      False\n      1\n      0\n      2\n      0\n    \n    \n      134\n      https://anthologiagraeca.org/api/passages/urn:...\n      3.2\n      3\n      False\n      1\n      0\n      0\n      0\n    \n    \n      135\n      https://anthologiagraeca.org/api/passages/urn:...\n      3.3\n      3\n      False\n      1\n      0\n      0\n      0\n    \n    \n      136\n      https://anthologiagraeca.org/api/passages/urn:...\n      3.4\n      3\n      False\n      1\n      0\n      0\n      0\n    \n    \n      137\n      https://anthologiagraeca.org/api/passages/urn:...\n      3.5\n      3\n      False\n      1\n      0\n      0\n      0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      4121\n      https://anthologiagraeca.org/api/passages/urn:...\n      16.376\n      16\n      False\n      1\n      0\n      0\n      0\n    \n    \n      4122\n      https://anthologiagraeca.org/api/passages/urn:...\n      16.377\n      16\n      False\n      1\n      0\n      0\n      0\n    \n    \n      4123\n      https://anthologiagraeca.org/api/passages/urn:...\n      16.378\n      16\n      False\n      1\n      0\n      0\n      0\n    \n    \n      4124\n      https://anthologiagraeca.org/api/passages/urn:...\n      16.379\n      16\n      False\n      1\n      0\n      0\n      0\n    \n    \n      4125\n      https://anthologiagraeca.org/api/passages/urn:...\n      16.380\n      16\n      False\n      1\n      0\n      0\n      0\n    \n  \n\n888 rows × 8 columns\n\n\n\nMais le but de notre expérience est de visualiser nos données ; toujours avec Pandas dans un premier temps, affichons combien de textes ont les épigrammes :\n\n\nCode\nplt.show(api_data_df['texts'].value_counts().plot(kind='bar'))\nplt.show(api_data_df['texts'].value_counts().plot(kind='pie'))\n\n\n\n\n\n\n\nUne visualisation en plots,\n\n\n\n\n\n\n\net une autre en pie.\n\n\n\n\n\n\nCombien de textes ont les épigrammes?\n\n\n\n\nPour résumer, quel est le nombre moyen de textes par épigramme ? Et quelle est la médiane de textes par épigramme ?\n\n\nCode\nprint(\"les épigrammes ont en moyenne\", api_data_df['texts'].mean(), \"textes\")\n\nprint(\"la médiane des textes par épigramme est de\", api_data_df['texts'].median())\n\n\nles épigrammes ont en moyenne 2.7960812772133528 textes\nla médiane des textes par épigramme est de 3.0\n\n\nQuelle est le nombre moyen de textes par épigramme selon les livres ?\n\n\nCode\napi_data_df[['book', 'texts']].groupby('book').mean()\n\n\n\n\n\n\n  \n    \n      \n      texts\n    \n    \n      book\n      \n    \n  \n  \n    \n      1\n      3.373984\n    \n    \n      2\n      2.000000\n    \n    \n      3\n      1.000000\n    \n    \n      4\n      4.800000\n    \n    \n      5\n      3.819355\n    \n    \n      6\n      3.030641\n    \n    \n      7\n      4.036939\n    \n    \n      8\n      3.364341\n    \n    \n      9\n      2.098676\n    \n    \n      10\n      1.283465\n    \n    \n      11\n      3.033860\n    \n    \n      12\n      3.565385\n    \n    \n      13\n      1.250000\n    \n    \n      14\n      1.258278\n    \n    \n      15\n      1.019231\n    \n    \n      16\n      1.060606\n    \n  \n\n\n\n\nVisualisons ce tableau dans un graphique qui nous indique le nombre moyen qu’ont les épigrammes de chacun des livres :\n\n\nCode\napi_data_df[['book', 'texts']].groupby('book').mean().plot(kind='bar', title=\"Moyenne des textes par épigrammes dans les livres de l'AG\")\n\n\n<AxesSubplot:title={'center':\"Moyenne des textes par épigrammes dans les livres de l'AG\"}, xlabel='book'>\n\n\n\n\n\nDans une même idée, nous pouvons montrer le nombre d’épigrammes par livre…\n\n\nCode\napi_data_df['book'].value_counts().plot.bar(title='text')\n\n\n<AxesSubplot:title={'center':'text'}>\n\n\n\n\n\n\n\nCode\nbook_counts = api_data_df['book'].value_counts()\nbook_counts_sorted = book_counts.sort_values(ascending=True)\n\n\n\n\nCode\nplt.bar(book_counts_sorted.index, book_counts_sorted)\nplt.xlabel('Livre')\nplt.ylabel('Compte')\nplt.title(\"Combien d'épigrammes a chaque livre\")\nplt.xticks(rotation=90)  # Pour faire pivoter les étiquettes de l'axe x si nécessaire\nplt.show()"
  },
  {
    "objectID": "Prefinal.html#perfect-epigram",
    "href": "Prefinal.html#perfect-epigram",
    "title": "Anthologie grecque. Visualisations",
    "section": "Perfect Epigram",
    "text": "Perfect Epigram\n\n\nCode\nmykw = []\nfor i in range(len(data_from_API)):\n    book_ = data_from_API[i]['book']['number']\n    count_ = len([i for i in data_from_API[i]['keywords']])\n    url_ = data_from_API[i]['url']\n    mykw.append({'book':book_,'count':count_, 'url':url_})\nmykw_df = pd.DataFrame(mykw)\n\n\n\n\nCode\n#df_ = mykw_df.groupby('count',as_index=False)['url'].agg(list)\n#df_[df_['count']==53]['url'].tolist()\n\n\n\n\nCode\ndef myapply(df):\n    #print(df['count'].value_counts())\n    mylist = [0,1,2,5,10,60]\n    mycounts = pd.cut(df['count'], mylist, right=False, labels=[\"0\",\"1\",\"2-4\",\"5-9\",\"10-59\"]).value_counts()\n    mydict = mycounts.to_dict()\n    mydict['book'] = df['book'].values[0]\n    return pd.Series(mydict).to_frame().T\n\ndict_list = mykw_df.groupby('book',as_index=False).apply(myapply)\ncount_df = dict_list.reset_index(drop=True)\ncount_df = count_df.set_index('book')\ncount_df_ = count_df[[\"0\",\"1\",\"2-4\",\"5-9\",\"10-59\"][::-1]]\nimport numpy  as np\n#count_df_.loc[:] = np.log(count_df_.values)\nplt.figure(dpi=100,figsize=(8,5))\nsns.heatmap(count_df_.T,annot=True,fmt='d')\n\n\n<AxesSubplot:xlabel='book'>\n\n\n\n\n\n\n\nCode\nprint(mykw_df['count'].value_counts())\n\n\n0     1909\n1      378\n4      330\n7      291\n6      269\n8      239\n2      168\n5      167\n9      152\n3       85\n10      76\n11      35\n12      20\n14       5\n13       3\n20       1\n19       1\n53       1\n16       1\n18       1\n15       1\n17       1\nName: count, dtype: int64\n\n\n\n\nCode\n0\n1 \n2-4 \n5-9\n10-60\n\n\n-50\n\n\n\nBOKEH\n\n\nCode\nimport numpy as np # we will use this later, so import it now\n\nfrom bokeh.io import output_notebook, show\nfrom bokeh.plotting import figure\n\noutput_notebook()\n\n\n\n    \n        \n        Loading BokehJS ...\n    \n\n\n\n\n\n\n\n\nOK - Epigrammes par livre\n\n\nCode\n# Dictionnaire pour stocker les compteurs de chaque livre\ncompteurs_livres = {}\n\n# Comptage des éléments par livre\nfor element in data_from_API:\n    url_livre = element['book']['number']\n    \n    # Vérification de l'existence de la clé dans le dictionnaire\n    if url_livre in compteurs_livres:\n        # Incrémentation du compteur\n        compteurs_livres[url_livre] += 1\n    else:\n        # Initialisation du compteur\n        compteurs_livres[url_livre] = 1\n\n# Affichage des résultats\nfor url_livre, compteurs in compteurs_livres.items():\n    print(f\"Livre : {url_livre}, Nombre d'éléments : {compteurs}\")\n\n\nLivre : 1, Nombre d'éléments : 123\nLivre : 2, Nombre d'éléments : 10\nLivre : 3, Nombre d'éléments : 19\nLivre : 4, Nombre d'éléments : 5\nLivre : 5, Nombre d'éléments : 310\nLivre : 6, Nombre d'éléments : 359\nLivre : 7, Nombre d'éléments : 758\nLivre : 8, Nombre d'éléments : 258\nLivre : 9, Nombre d'éléments : 831\nLivre : 10, Nombre d'éléments : 127\nLivre : 11, Nombre d'éléments : 443\nLivre : 12, Nombre d'éléments : 260\nLivre : 13, Nombre d'éléments : 32\nLivre : 14, Nombre d'éléments : 151\nLivre : 15, Nombre d'éléments : 52\nLivre : 16, Nombre d'éléments : 396\n\n\n\n\nCode\n# create a new plot with default tools, using figure\np = figure(width=400, height=400)\n\n# add a circle renderer with x and y coordinates, size, color, and alpha\np.hex(list(compteurs_livres.keys()), list(compteurs_livres.values()), size=15, line_color=\"navy\", fill_color=\"orange\", fill_alpha=0.5)\n\nshow(p) # show the results\n\n\n\n  \n\n\n\n\n\nNous pouvons également représenter cela dans un Pie Chart interactif !\n\n\nCode\nfrom math import pi\nimport pandas as pd\nfrom bokeh.palettes import Category20c\nfrom bokeh.transform import cumsum\nfrom bokeh.models import Legend, Wedge, ColumnDataSource\n\nx = compteurs_livres\n\ndata = pd.Series(x).reset_index(name='value').rename(columns={'index':'livre'})\ndata['color'] = Category20c[len(x)]\n\n# represent each value as an angle = value / total * 2pi\ndata['angle'] = data['value']/data['value'].sum() * 2*pi\n\np = figure(height=450, title=\"Nombre d'épigrammes par livre\", toolbar_location=None,\n           tools=\"hover\", tooltips=\"@livre: @value\")\n\np.wedge(x=0, y=1, radius=0.4, \n        \n        # use cumsum to cumulatively sum the values for start and end angles\n        start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),\n        line_color=\"white\", fill_color='color', legend_field='livre', source=data)\n\np.axis.axis_label=None\np.axis.visible=False\np.grid.grid_line_color = None\nshow(p)\n\n\n\n  \n\n\n\n\n\n\n\nCode\nitems=[]\nfor i in range(len(data_from_API)):\n    id_ = data_from_API[i]['id']\n    langs_ = [i['language'] for i in data_from_API[i]['texts']]\n    items.append((id_,langs_))\n\n\n\n\nCode\nmy_df=pd.DataFrame(items,columns=['id','langs'])\nmy_df=my_df.explode('langs')\nmy_langs = my_df['langs'].value_counts()\n#print(my_df[my_df['langs']=='deu'])\n\n\n\n\nCode\nfor x in data_from_API:   \n    if x['id']==4049: \n        print(x['url'])\n\n\n\n\nCode\nmy_langs_ = my_langs.rename_axis('Langue de Traduction').reset_index(name='Nombre de textes')\n#print(my_langs_)\nplt.figure(dpi=75)\nsns.barplot(data=my_langs_,x='Langue de Traduction',y='Nombre de textes',palette=\"hls\")"
  }
]